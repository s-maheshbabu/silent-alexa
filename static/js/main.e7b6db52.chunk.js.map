{"version":3,"sources":["constants/CannedResponses.js","constants/CannedErrorResponses.js","components/HeaderFlatButton/HeaderFlatButton.js","constants/Constants.js","components/LoginControl/LoginControl.js","components/Header/Header.js","components/ChatBubble/ChatBubble.css.js","components/ChatBubble/ChatBubble.js","components/UserRequestToAlexaForm/UserRequestToAlexaForm.js","components/Icons/AlexaRingIcon.js","constants/Chatters.js","errors/IllegalArgumentError.js","avs/SpeakDirectiveParser.js","avs/AVSGateway.js","components/ChatWindow/ChatWindow.js","components/RightPanel/RightPanel.js","components/WelcomeScreen/WelcomeScreen.js","components/Body/Body.js","components/Footer/Footer.js","components/LoginHandler/LoginHandler.js","components/DefaultRedirect/DefaultRedirect.js","components/LoginFailedScreen/LoginFailedScreen.js","components/Routes/Routes.js","components/App/App.js","auth/AuthContextProvider.js","registerServiceWorker.js","index.js","constants/AVSEndPoints.js"],"names":["cannedResponses","Object","freeze","EMPTY_RESPONSE_FROM_ALEXA","module","exports","cannedErrorResponses","Map","require","INVALID_REQUEST_EXCEPTION","UNAUTHORIZED_REQUEST_EXCEPTION","UNSUPPORTED_MEDIA_TYPE","THROTTLING_EXCEPTION","INTERNAL_SERVICE_EXCEPTION","UNKNOWN_ERROR","customErrorCodes","HeaderFlatButton","props","className","label","onClick","AMAZON_LOGIN_COOKIE","options","scope","scope_data","productID","productInstanceAttributes","deviceSerialNumber","popup","LoginControl","useCookies","cookies","removeCookie","undefined","maxAge","secure","path","clearAccessTokens","handleLogin","window","amazon","Login","authorize","location","origin","Header","id","showMenuIconButton","title","iconElementRight","text","fontSize","chatbubble","background","userBubble","message","bubbleStyles","styles","UserRequestToAlexaForm","onSubmit","e","hintText","value","onChange","AlexaRingIcon","width","viewBox","fill","d","transform","chatterIds","USER","ALEXA","chatters","name","avatar","IllegalArgumentError","Error","extractAlexaTextResponses","alexaRawResponse","parsedResponse","httpMessageParser","multipart","textParts","filter","part","getIn","body","map","alexaResponses","avsDirective","JSON","parse","error","toString","util","inspect","showHidden","depth","_validateDirective","_isSpeakDirective","hasIn","push","directive","payload","caption","console","log","fromJS","header","sprintf","EVENTS_URL","urls","NA","paths","EVENTS","AVSGateway","userRequestToAlexa","accessToken","testMessageEvent","stringify","this","buildTextMessageEvent","requestOptions","buildTextMessageFetchRequestOptions","isOk","fetch","then","response","ok","json","data","catch","textResponsesFromAlexa","parser","get","List","of","convertErrorToHumanReadableMessage","errorPayload","errorCode","code","headers","Authorization","cache","method","requestString","event","namespace","messageId","uuid","textMessage","avs","ChatWindow","state","messages","Message","senderName","is_typing","preventDefault","length","setState","pushMessage","history","access_token","remove","sendTextMessageEvent","alexaResponse","userId","user","messagesCopy","slice","newMessage","target","height","isTyping","hasInputField","showSenderName","bubblesCentered","maxHeight","chatBubble","ChatBubble","handleChangeInUserRequestToAlexa","onUserRequestToAlexaSubmit","Component","withRouter","withCookies","RightPanel","WelcomeScreen","Body","key","Footer","href","LoginHandler","lwaResponse","setCookie","queryString","hash","parseNumbers","expires_in","isLWAResponseValid","to","DefaultRedirect","React","LoginFailedScreen","Routes","exact","render","routeProps","App","AuthContext","createContext","children","defaultContext","setLWAResponse","_persist","isAuthenticated","Cookies","getAccessToken","clear","Provider","serializedLWAResponse","set","expires","isLocalhost","Boolean","hostname","match","registerValidSW","swUrl","navigator","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","controller","ReactDOM","CookiesProvider","document","getElementById","URL","process","addEventListener","status","indexOf","ready","unregister","reload","checkValidServiceWorker","registerServiceWorker","DIRECTIVES","EU","FE"],"mappings":"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","file":"static/js/main.e7b6db52.chunk.js","sourcesContent":["const cannedResponses = Object.freeze({\n  /* Message to be delivered when Alexa responds with an empty message. This is a valid scenario,\n   for example, when user says \"stop talking\" to Alexa.*/\n  EMPTY_RESPONSE_FROM_ALEXA:\n    \"a canned response when Alexa repsonds with an empty message.\"\n});\n\nmodule.exports = {\n  cannedResponses: cannedResponses\n};\n","const { Map } = require(\"immutable\");\n\n/**\n * We need to show human readable error messages to users when Alexa responds\n * with error codes or we encounter internal/unknown errors.\n * This is a mapping from Alexa/Custom error codes to canned responses.\n * @link https://developer.amazon.com/docs/alexa-voice-service/exceptions.html\n */\n// TODO: Change the place holder error responses to real ones.\nconst cannedErrorResponses = Map({\n  INVALID_REQUEST_EXCEPTION: \"a canned response for INVALID_REQUEST_EXCEPTION\",\n  UNAUTHORIZED_REQUEST_EXCEPTION:\n    \"a canned response for UNAUTHORIZED_REQUEST_EXCEPTION\",\n  UNSUPPORTED_MEDIA_TYPE: \"a canned response for UNSUPPORTED_MEDIA_TYPE\",\n  THROTTLING_EXCEPTION: \"a canned response for THROTTLING_EXCEPTION\",\n  INTERNAL_SERVICE_EXCEPTION:\n    \"a canned response for INTERNAL_SERVICE_EXCEPTION\",\n  \"N/A\": \"a canned response for N/A Exception\",\n\n  UNKNOWN_ERROR:\n    \"a canned response for UNKNOWN_ERROR. This shouldn't ever happen. Don't show it as an Alexa bubble.\"\n});\n\nconst customErrorCodes = Object.freeze({\n  UNKNOWN_ERROR: \"UNKNOWN_ERROR\"\n});\n\nmodule.exports = {\n  cannedErrorResponses: cannedErrorResponses,\n  customErrorCodes: customErrorCodes\n};\n","import React from \"react\";\nimport FlatButton from \"material-ui/FlatButton\";\n\nimport \"./HeaderFlatButton.css\";\n\nexport default function HeaderFlatButton(props) {\n  return (\n    <FlatButton\n      className=\"header-flat-button\"\n      label={props.label}\n      onClick={() => props.onClick()}\n    />\n  );\n}\n","export const DEFAULT_PLACEHOLDER_FOR_USER_REQUEST_STRING =\n  \"Type your request for Alexa..\";\n\nexport const AMAZON_LOGIN_COOKIE = \"amazon_Login_accessToken\";\n","import React from \"react\";\nimport HeaderFlatButton from \"HeaderFlatButton/HeaderFlatButton\";\nimport { useCookies } from \"react-cookie\";\n\nimport { AMAZON_LOGIN_COOKIE } from \"Constants\";\n\n// TODO: Logic for assigning 'deviceSerialNumber' needs to be revisited.\n// LWA options to request implicit grant.\nexport const options = Object.freeze({\n  scope: [\"alexa:all\", \"profile\"],\n  scope_data: {\n    \"alexa:all\": {\n      productID: \"Silent_Alexa\",\n      productInstanceAttributes: { deviceSerialNumber: \"12345\" }\n    }\n  },\n  popup: false\n});\n\n// Redirect path to handle the response from LoginWithAmazon\nexport const REDIRECT_PATH = \"/authresponse\";\n\nexport default function LoginControl() {\n  const [cookies, removeCookie] = useCookies([AMAZON_LOGIN_COOKIE]);\n\n  if (cookies[AMAZON_LOGIN_COOKIE] !== undefined) {\n    return <HeaderFlatButton label=\"Logout\" onClick={() =>\n      clearAccessTokens(removeCookie)\n    } />;\n  } else {\n    return <HeaderFlatButton label=\"Login\" onClick={handleLogin} />;\n  }\n}\n\nfunction clearAccessTokens(removeCookie) {\n  removeCookie(AMAZON_LOGIN_COOKIE, undefined, {\n    maxAge: 0,\n    secure: false, // TODO: Change localhost to also use https and then change this to true.\n    path: \"/\"\n  });\n}\n\nfunction handleLogin() {\n  // The authorization service will redirect the user-agent to the redirect path\n  // which will contain an authorization response as a URI fragment\n  window.amazon.Login.authorize(\n    options,\n    window.location.origin + REDIRECT_PATH\n  );\n}\n","import React from \"react\";\nimport AppBar from \"material-ui/AppBar\";\nimport MuiThemeProvider from \"material-ui/styles/MuiThemeProvider\";\n\nimport LoginControl from \"LoginControl/LoginControl\";\nimport \"./Header.css\";\n\nfunction _LoginControlInHeader() {\n  return <LoginControl />;\n}\n\nexport default function Header(props) {\n  return (\n    <div id=\"header\">\n      <div id=\"header-info\">\n        <MuiThemeProvider>\n          <AppBar\n            className=\"app-bar\"\n            showMenuIconButton={false}\n            title=\"Silent Alexa (Under Construction)\"\n            iconElementRight={_LoginControlInHeader(props)}\n          />\n        </MuiThemeProvider>\n      </div>\n    </div>\n  );\n}\n","export default {\n  bubbleStyles: {\n    text: {\n      fontSize: 20\n    },\n    chatbubble: {\n      background: \"#00ACE0\"\n    },\n    userBubble: {\n      background: \"#646A72\"\n    }\n  }\n};\n","import React from \"react\";\nimport { ChatBubble } from \"monkas-chat\";\n\nimport styles from \"./ChatBubble.css.js\";\n\nexport default function(props) {\n  return (\n    <ChatBubble\n      message={props.message}\n      bubbleStyles={{\n        ...styles.bubbleStyles\n      }}\n    />\n  );\n}\n","import React from \"react\";\nimport TextField from \"material-ui/TextField\";\nimport MuiThemeProvider from \"material-ui/styles/MuiThemeProvider\";\n\nimport { DEFAULT_PLACEHOLDER_FOR_USER_REQUEST_STRING } from \"Constants\";\n\n/*\nThe input component where user's type in their requests for Alexa\n*/\nconst UserRequestToAlexaForm = props => {\n  return (\n    <form onSubmit={e => props.onSubmit(e)}>\n      <MuiThemeProvider>\n        <TextField\n          id=\"user-request-to-alexa-text-field\"\n          hintText={DEFAULT_PLACEHOLDER_FOR_USER_REQUEST_STRING}\n          value={props.value}\n          onChange={e => props.onChange(e)}\n        />\n      </MuiThemeProvider>\n    </form>\n  );\n};\n\nexport default UserRequestToAlexaForm;\n","import React from \"react\";\n\nexport default function AlexaRingIcon() {\n  return (\n    <svg width=\"24\" viewBox=\"0 0 24 24\">\n      <path\n        fill=\"#00ACE0\"\n        d=\"M0,10.0000489 C0,15.0707816 3.77428289,19.2594477 8.66667972,19.9113334 L8.66667972,17.8962718 C8.66667972,17.3281595 8.30829606,16.8174945 7.76974193,16.636736 C4.94690794,15.688512 2.927648,12.9904434 3.00202582,9.8313279 C3.09245359,5.9853886 6.22532565,2.96152397 10.0722248,3.00037678 C13.9049334,3.03913173 16.9999315,6.15812215 16.9999315,10.0000489 C16.9999315,10.087639 16.9977785,10.1747398 16.9945489,10.2614491 C16.9887748,10.4004189 16.9838815,10.4807669 16.9775203,10.5606256 C16.975563,10.5860707 16.9731163,10.611418 16.9707676,10.6367653 C16.9658743,10.692549 16.9601002,10.7479411 16.9538368,10.8032355 C16.9466926,10.8660654 16.9385698,10.928504 16.9298598,10.9906489 C16.9258473,11.01903 16.9220305,11.0475091 16.9177244,11.0756945 C16.0607158,16.7212922 8.70778325,19.8942068 8.66756051,19.9115291 C9.10355154,19.9694658 9.54815475,20 9.99990213,20 C15.5228467,20 20,15.5229227 20,10.0000489 C20,4.47717519 15.5228467,0 9.99990213,0 C4.47715329,0 0,4.47717519 0,10.0000489 Z\"\n        transform=\"translate(2 2)\"\n      />\n    </svg>\n  );\n}\n","import React from \"react\";\nimport { Map } from \"immutable\";\nimport AlexaRingIcon from \"Icons/AlexaRingIcon\";\n\nconst chatterIds = Object.freeze({\n  USER: 0,\n  ALEXA: 1\n});\n\nconst chatters = Map([\n  [chatterIds.USER, { name: \"You\", avatar: undefined }],\n  [\n    chatterIds.ALEXA,\n    {\n      avatar: <AlexaRingIcon />\n    }\n  ]\n]);\n\nexport { chatterIds, chatters };\n","class IllegalArgumentError extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    this.name = \"IllegalArgumentError\";\n  }\n}\n\nexport default IllegalArgumentError;\n","import IllegalArgumentError from \"errors/IllegalArgumentError\";\n\nimport { hasIn, getIn, fromJS } from \"immutable\";\nimport util from \"util\";\nimport httpMessageParser from \"http-message-parser\";\n\nconst TEXT_PART_CONTENT_TYPE = `application/json; charset=UTF-8`;\n/**\n * This method parses the multi-part AVS responses and extracts the\n * strings representing Alexa's responses from 'Speak' directives.\n * It strips away other information like binary audio data, ssml\n * tags etc in the 'Speak' directives.\n *\n * @param {String} alexaRawResponse The multi-part response from AVS. This\n * should not be empty or undefined.\n *\n * @returns a List of text responses from Alexa. All the responses will be\n * valid strings but a response can be empty if Alexa chooses to say nothing.\n *\n * @throws IllegalArgumentError if Alexa's response couldn't be parsed out\n * of the input. The failure could be because the input is not well formatted\n * or doesn't contain the right fields to fetch Alexa's response.\n */\nexport function extractAlexaTextResponses(alexaRawResponse) {\n  if (!alexaRawResponse) {\n    throw new IllegalArgumentError(\n      \"The response to be parsed cannot be empty. Input: \" + alexaRawResponse\n    );\n  }\n\n  const parsedResponse = httpMessageParser(alexaRawResponse);\n  // TODO: !parsedResponse condition isn't tested because mocking httpMessageParser responses turned\n  // out to be more involved than expected. While it is safe for now because the library appears to\n  // always return a response that contains a body, it needs to be tested.\n  if (!parsedResponse || !parsedResponse.multipart) {\n    throw new IllegalArgumentError(\n      \"Given raw response is not a valid multi-part message. Input: \" +\n        alexaRawResponse\n    );\n  }\n\n  // TODO: part.headers and part.body being undefined or null isn't tested because\n  // mocking httpMessageParser responses turned out to be more involved than expected.\n  // While it is safe for now because the library appears to always return a response\n  // that contains a body, it needs to be tested.\n  const textParts = parsedResponse.multipart\n    .filter(\n      part =>\n        TEXT_PART_CONTENT_TYPE === getIn(part, [\"headers\", \"Content-Type\"]) &&\n        part.body\n    )\n    .map(part => part.body);\n\n  const alexaResponses = [];\n  for (let part of textParts) {\n    let avsDirective;\n    try {\n      avsDirective = JSON.parse(part);\n    } catch (error) {\n      throw new IllegalArgumentError(\n        `Given directive couldn't be parsed to a JSON object. Input: \" ${part.toString()}\n        StackTrace:\n        ${util.inspect(error, { showHidden: true, depth: null })}`\n      );\n    }\n\n    _validateDirective(avsDirective);\n    // Directives that are not Speak directives (for ex, ExpectSpeech** directive) will be skipped for now. Tracking\n    // item to handle ExpectSpeech directives - https://github.com/s-maheshbabu/silent-alexa/issues/62\n    // ** https://developer.amazon.com/docs/alexa-voice-service/speechrecognizer.html#expectspeech\n    if (!_isSpeakDirective(avsDirective)) {\n      console.log(\n        \"A non-Speak directive was encountered. Skipping the directive. \" +\n          util.inspect(avsDirective, { showHidden: true, depth: null })\n      );\n      continue;\n    }\n\n    if (!hasIn(avsDirective, [\"directive\", \"payload\", \"caption\"]))\n      throw new IllegalArgumentError(\n        \"Given Speak directive doesn't contain the expected path directive.payload.caption. Input: \" +\n          `${util.inspect(avsDirective, { showHidden: true, depth: null })}`\n      );\n\n    alexaResponses.push(avsDirective.directive.payload.caption);\n  }\n\n  return fromJS(alexaResponses);\n}\n\nfunction _validateDirective(avsDirective) {\n  if (!hasIn(avsDirective, [\"directive\", \"header\", \"name\"]))\n    throw new IllegalArgumentError(\n      \"Given directive doesn't declare a type at directive.header.name. Input: \" +\n        `${util.inspect(avsDirective, { showHidden: true, depth: null })}`\n    );\n}\n\nfunction _isSpeakDirective(avsDirective) {\n  return avsDirective.directive.header.name === \"Speak\";\n}\n","import { urls, paths } from \"AVSEndPoints\";\nimport { cannedErrorResponses, customErrorCodes } from \"CannedErrorResponses\";\nimport { cannedResponses } from \"CannedResponses\";\n\nimport IllegalArgumentError from \"errors/IllegalArgumentError\";\nimport { extractAlexaTextResponses as parser } from \"SpeakDirectiveParser\";\n\nimport { hasIn, List } from \"immutable\";\nimport uuid from \"uuid/v4\";\nimport util from \"util\";\n\nconst sprintf = require(\"sprintf-js\").sprintf;\n\nconst AVS_REQUEST_BODY = `--silent-alexa-http-boundary\nContent-Disposition: form-data; name=\"metadata\"\nContent-Type: application/json; charset=UTF-8\n\n%s`;\n\n// TODO: Once the region setting is made configurable by the user, the URLS\n// need to ge generated as against hard coded.\nexport const EVENTS_URL = urls.NA + paths.EVENTS;\n\n/**\n * Manages interactions with AVS\n */\nexport default class AVSGateway {\n  /**\n   * Sends the TextMessage event to AVS and extracts Alexa's responses.\n   *\n   * @param {String} userRequestToAlexa The request string that the user typed\n   * as a request for Alexa. This should not be empty or undefined.\n   * @param {String} accessToken The access token to communicate with AVS. This\n   * should not be empty of undefined.\n   *\n   * @returns A list of text responses from Alexa. Will never return undefined or\n   * empty list. If an error happens while communicating to AVS or while parsing\n   * the responses, a canned human-readable error message is returned.\n   *\n   * @throws IllegalArgumentError if the input is missing or invalid.\n   */\n  async sendTextMessageEvent(userRequestToAlexa, accessToken) {\n    if (!userRequestToAlexa || !accessToken) {\n      throw new IllegalArgumentError(\n        `The request string to Alexa or the access token cannot be empty.\n        RequestString: ${userRequestToAlexa}\n        AccessToken: ${accessToken}`\n      );\n    }\n\n    const testMessageEvent = JSON.stringify(\n      this.buildTextMessageEvent(userRequestToAlexa)\n    );\n    const requestOptions = this.buildTextMessageFetchRequestOptions(\n      testMessageEvent,\n      accessToken\n    );\n\n    let isOk = false;\n    let payload;\n    await fetch(EVENTS_URL, requestOptions)\n      .then(response => {\n        if (response.ok) {\n          isOk = true;\n          return response.text();\n        } else {\n          return response.json();\n        }\n      })\n      .then(data => {\n        payload = data;\n      })\n      .catch(error => {\n        isOk = false; // We obtained a successful response but couldn't parse the body, probably because it was malformed.\n        console.log(util.inspect(error, { showHidden: true, depth: null }));\n      });\n\n    if (isOk) {\n      try {\n        let textResponsesFromAlexa;\n        if (payload) textResponsesFromAlexa = parser(payload);\n        if (\n          !textResponsesFromAlexa ||\n          // We don't anticipate Alexa to return a response in multiple parts where the first part is empty\n          // but the other parts aren't. So, the moment we see that the first part is empty, it is safe to\n          // ignore all other parts (which probably don't exist).\n          !textResponsesFromAlexa.get(0)\n        )\n          textResponsesFromAlexa = List.of(\n            cannedResponses.EMPTY_RESPONSE_FROM_ALEXA\n          );\n\n        return textResponsesFromAlexa;\n      } catch (error) {\n        console.log(\n          \"Encountered an error while trying to parse the speak directive from AVS.\" +\n          util.inspect(error, { showHidden: true, depth: null })\n        );\n      }\n    }\n\n    return List.of(this.convertErrorToHumanReadableMessage(payload));\n  }\n\n  convertErrorToHumanReadableMessage(errorPayload) {\n    let errorCode;\n    if (hasIn(errorPayload, [\"payload\", \"code\"]))\n      errorCode = errorPayload.payload.code;\n\n    return cannedErrorResponses.get(\n      errorCode,\n      // default value to return if errorCode doesn't exist\n      cannedErrorResponses.get(customErrorCodes.UNKNOWN_ERROR)\n    );\n  }\n\n  buildTextMessageFetchRequestOptions(testMessageEvent, accessToken) {\n    const data = sprintf(AVS_REQUEST_BODY, testMessageEvent);\n\n    return {\n      body: data,\n      headers: {\n        Authorization: \"Bearer \" + accessToken,\n        \"content-type\":\n          \"multipart/form-data; boundary=silent-alexa-http-boundary\"\n      },\n      cache: \"no-store\", // Alexa often responds differently to the same request and so we don't want to cache anything.\n      method: \"POST\"\n    };\n  }\n\n  buildTextMessageEvent(requestString) {\n    return {\n      event: {\n        header: {\n          namespace: \"Text\",\n          name: \"TextMessage\",\n          messageId: uuid()\n        },\n        payload: {\n          textMessage: requestString\n        }\n      }\n    };\n  }\n}\n","import React, { Component } from \"react\";\nimport { ChatFeed, Message } from \"monkas-chat\";\nimport ContainerDimensions from \"react-container-dimensions\";\nimport { instanceOf } from 'prop-types';\n\nimport ChatBubble from \"ChatBubble/ChatBubble\";\nimport { cannedErrorResponses, customErrorCodes } from \"CannedErrorResponses\";\n\nimport UserRequestToAlexaForm from \"UserRequestToAlexaForm/UserRequestToAlexaForm\";\nimport \"./ChatWindow.css\";\n\nimport { chatters, chatterIds } from \"Chatters\";\n\nimport AVSGateway from \"AVSGateway\";\nimport { withRouter } from 'react-router-dom';\nimport { withCookies, Cookies } from \"react-cookie\";\n\nimport { AMAZON_LOGIN_COOKIE } from \"Constants\";\nconst avs = new AVSGateway();\n\n// TODO: Existing dependency for chat window is not supported. Just making a note of\n// a potentially better supported solution https://github.com/FaridSafi/react-native-gifted-chat\nclass ChatWindow extends Component {\n  static propTypes = {\n    cookies: instanceOf(Cookies).isRequired\n  };\n\n  constructor() {\n    super();\n    this.state = {\n      messages: [\n        new Message({\n          id: chatterIds.USER,\n          message: \"Hello Alexa!\",\n          senderName: chatters.get(chatterIds.USER).name\n        }),\n        new Message({\n          id: chatterIds.ALEXA,\n          message: \"Hey! Alexa here.\",\n          avatar: chatters.get(chatterIds.ALEXA).avatar\n        }),\n        // TODO Adding a bunch of dummy messages to make the ChatFeed overflow window height.\n        // This will be useful during the development phase but will be removed once we are confident about the layout.\n        new Message({\n          id: chatterIds.USER,\n          message: \"Hello Alexa!\",\n          senderName: chatters.get(chatterIds.USER).name\n        }),\n        new Message({\n          id: chatterIds.ALEXA,\n          message: \"Hey! Alexa here.\",\n          avatar: chatters.get(chatterIds.ALEXA).avatar\n        }),\n        new Message({\n          id: chatterIds.USER,\n          message: \"Hello Alexa!\",\n          senderName: chatters.get(chatterIds.USER).name\n        }),\n        new Message({\n          id: chatterIds.ALEXA,\n          message: \"Hey! Alexa here.\",\n          avatar: chatters.get(chatterIds.ALEXA).avatar\n        }),\n        new Message({\n          id: chatterIds.USER,\n          message: \"Hello Alexa!\",\n          senderName: chatters.get(chatterIds.USER).name\n        }),\n        new Message({\n          id: chatterIds.ALEXA,\n          message: \"Hey! Alexa here.\",\n          avatar: chatters.get(chatterIds.ALEXA).avatar\n        }),\n        new Message({\n          id: chatterIds.USER,\n          message: \"Hello Alexa!\",\n          senderName: chatters.get(chatterIds.USER).name\n        }),\n        new Message({\n          id: chatterIds.ALEXA,\n          message: \"Hey! Alexa here.\",\n          avatar: chatters.get(chatterIds.ALEXA).avatar\n        }),\n        new Message({\n          id: chatterIds.USER,\n          message: \"Hello Alexa!\",\n          senderName: chatters.get(chatterIds.USER).name\n        }),\n        new Message({\n          id: chatterIds.ALEXA,\n          message: \"Hey! Alexa here.\",\n          avatar: chatters.get(chatterIds.ALEXA).avatar\n        }),\n        new Message({\n          id: chatterIds.USER,\n          message: \"Hello Alexa!\",\n          senderName: chatters.get(chatterIds.USER).name\n        }),\n        new Message({\n          id: chatterIds.ALEXA,\n          message: \"Hey! Alexa here.\",\n          avatar: chatters.get(chatterIds.ALEXA).avatar\n        }),\n        new Message({\n          id: chatterIds.USER,\n          message: \"Hello Alexa!\",\n          senderName: chatters.get(chatterIds.USER).name\n        }),\n        new Message({\n          id: chatterIds.ALEXA,\n          message: \"Hey! Alexa here.\",\n          avatar: chatters.get(chatterIds.ALEXA).avatar\n        }),\n        new Message({\n          id: chatterIds.USER,\n          message: \"Hello Alexa!\",\n          senderName: chatters.get(chatterIds.USER).name\n        }),\n        new Message({\n          id: chatterIds.ALEXA,\n          message: \"Hey! Alexa here.\",\n          avatar: chatters.get(chatterIds.ALEXA).avatar\n        }),\n        new Message({\n          id: chatterIds.USER,\n          message: \"Hello Alexa!\",\n          senderName: chatters.get(chatterIds.USER).name\n        }),\n        new Message({\n          id: chatterIds.ALEXA,\n          message: \"Hey! Alexa here.\",\n          avatar: chatters.get(chatterIds.ALEXA).avatar\n        }),\n        new Message({\n          id: chatterIds.USER,\n          message: \"Hello Alexa!\",\n          senderName: chatters.get(chatterIds.USER).name\n        }),\n        new Message({\n          id: chatterIds.ALEXA,\n          message: \"Hey! Alexa here.\",\n          avatar: chatters.get(chatterIds.ALEXA).avatar\n        }),\n        new Message({\n          id: chatterIds.USER,\n          message: \"Hello Alexa!\",\n          senderName: chatters.get(chatterIds.USER).name\n        })\n      ],\n      userRequestToAlexa: \"\",\n      is_typing: false\n    };\n  }\n\n  /*\n  Once the user submits the request for Alexa, we need to update the messages\n  in the state so the chat window gets updated.\n  */\n  onUserRequestToAlexaSubmit(event) {\n    const userRequestToAlexa = this.state.userRequestToAlexa;\n    event.preventDefault();\n    if (!userRequestToAlexa || 0 === userRequestToAlexa.length) {\n      console.log(\"Request string for Alexa was empty: \" + userRequestToAlexa);\n      this.setState({ userRequestToAlexa: \"\" });\n      return;\n    }\n\n    this.pushMessage(chatterIds.USER, userRequestToAlexa);\n    this.setState({ userRequestToAlexa: \"\" });\n\n    const history = this.props.history;\n    const { cookies } = this.props;\n    const access_token = cookies.get(AMAZON_LOGIN_COOKIE);\n    if (access_token === undefined) {\n      cookies.remove(AMAZON_LOGIN_COOKIE, undefined, {\n        maxAge: 0,\n        secure: false, // TODO: Change localhost to also use https and then change this to true.\n        path: \"/\"\n      });\n\n      history.push(\"/access_denied\");\n      return;\n    }\n\n    avs\n      .sendTextMessageEvent(userRequestToAlexa, access_token)\n      .then(alexaResponses =>\n        alexaResponses.map(alexaResponse =>\n          this.pushMessage(chatterIds.ALEXA, alexaResponse)\n        )\n      )\n      .catch(error => {\n        // TODO: Don't show this as an Alexa bubble. It also doesn't make sense to show it as a user bubble.\n        // Need to find a way to represent this error on the UI.\n        this.pushMessage(\n          chatterIds.ALEXA,\n          cannedErrorResponses.get(customErrorCodes.UNKNOWN_ERROR)\n        );\n      });\n  }\n\n  pushMessage(userId, message) {\n    const user = chatters.get(userId);\n    if (!user) {\n      console.log(\"Unknown userId: \" + userId);\n      return;\n    }\n    if (!message || 0 === message.length) {\n      console.log(\"Empty message: \" + message);\n      return;\n    }\n\n    const messagesCopy = this.state.messages.slice(); // for immutability\n    const newMessage = new Message({\n      id: userId,\n      message,\n      senderName: user.name,\n      avatar: user.avatar\n    });\n    messagesCopy.push(newMessage);\n    this.setState({ messages: messagesCopy });\n  }\n\n  /*\n  Update the state as the user is typing into the input box\n  */\n  handleChangeInUserRequestToAlexa(event) {\n    event.preventDefault();\n    this.setState({ userRequestToAlexa: event.target.value });\n  }\n\n  render() {\n    return (\n      <div id=\"leftpanel\">\n        <div className=\"panel-body\">\n          <ContainerDimensions>\n            {({ height }) => (\n              <ChatFeed\n                messages={this.state.messages}\n                isTyping={this.state.is_typing} // is the recipient typing\n                hasInputField={false} // use the default input field that is provided along with ChatFeed component\n                showSenderName={true} // show the name of the user who sent the message\n                bubblesCentered={false}\n                maxHeight={height}\n                chatBubble={ChatBubble}\n              />\n            )}\n          </ContainerDimensions>\n        </div>\n        <div id=\"chat-input\">\n          <UserRequestToAlexaForm\n            value={this.state.userRequestToAlexa}\n            onChange={e => this.handleChangeInUserRequestToAlexa(e)}\n            onSubmit={e => this.onUserRequestToAlexaSubmit(e)}\n          />\n        </div>\n      </div>\n    );\n  }\n}\n\n// TODO: Use Recomponse to make it more readable. Even better if we can make this class\n// a function so we can just use hooks.\nexport default withRouter(withCookies(ChatWindow));\n","import React from \"react\";\nimport \"./RightPanel.css\";\n\nexport default function RightPanel() {\n  return (\n    <div id=\"rightpanel\">\n      <div className=\"panel-body\">Right side content</div>\n    </div>\n  );\n}\n","import React from \"react\";\nimport \"./WelcomeScreen.css\";\n\nexport default function WelcomeScreen() {\n  return (\n    <div id=\"welcome-screen\">\n      <h1> WELCOME TO SILENT ALEXA (Under Construction) </h1>\n      <h1> Login to get started </h1>\n    </div>\n  );\n}\n","import React from \"react\";\nimport MuiThemeProvider from \"material-ui/styles/MuiThemeProvider\";\nimport ChatWindow from \"ChatWindow/ChatWindow\";\nimport RightPanel from \"RightPanel/RightPanel\";\nimport WelcomeScreen from \"WelcomeScreen/WelcomeScreen\";\nimport { useCookies } from \"react-cookie\";\n\nimport { AMAZON_LOGIN_COOKIE } from \"Constants\";\n\nexport default function Body() {\n  const [cookies] = useCookies([AMAZON_LOGIN_COOKIE]);\n\n  if (cookies[AMAZON_LOGIN_COOKIE] !== undefined) {\n    return [\n      <MuiThemeProvider key=\"muiThemeProvider\">\n        <ChatWindow />\n      </MuiThemeProvider>,\n\n      <RightPanel key=\"rightPanel\" />\n    ];\n  }\n\n  return <WelcomeScreen />;\n}\n","import React from \"react\";\nimport \"./Footer.css\";\n\nexport default function Footer() {\n  return (\n    <div id=\"footer\">\n      <div id=\"footer-info\">\n        <span>Footer Info Bar</span>\n        <span> That Collapses</span>\n      </div>\n      <div id=\"footer-controls\">\n        <a href=\"http://example.com\">Clickable</a>\n        <a href=\"http://example.com\">icons</a>\n        <a href=\"http://example.com\">and</a>\n        <a href=\"http://example.com\">links</a>\n        <a href=\"http://example.com\">can</a>\n        <a href=\"http://example.com\">go</a>\n        <a href=\"http://example.com\">here</a>\n      </div>\n    </div>\n  );\n}\n","import React from \"react\";\nimport { Redirect } from \"react-router-dom\";\nimport queryString from \"query-string\";\nimport util from \"util\";\nimport { hasIn } from \"immutable\";\nimport { useCookies } from \"react-cookie\";\n\nimport { AMAZON_LOGIN_COOKIE } from \"Constants\";\n\nexport default function LoginHandler(props) {\n  const [, setCookie] = useCookies([AMAZON_LOGIN_COOKIE]);\n\n  let lwaResponse;\n  // Parses the query string to fetch the login with amazon response object\n  if (hasIn(props, [\"location\", \"hash\"])) {\n    lwaResponse = queryString.parse(props.location.hash, { parseNumbers: true });\n  }\n\n  if (isLWAResponseValid(lwaResponse)) {\n    setCookie(AMAZON_LOGIN_COOKIE, lwaResponse.access_token, {\n      maxAge: lwaResponse.expires_in, // TODO Why are cookies expiring in an hour?\n      secure: false, // TODO: Change localhost to also use https and then change this to true.\n      path: \"/\"\n    });\n\n    return <Redirect to=\"/\" />;\n  }\n  else\n    return <Redirect to=\"/access_denied\" />;\n}\n\n/**\n * @returns true if LoginWithAmazon response is valid\n *          false, otherwise.\n */\nfunction isLWAResponseValid(lwaResponse) {\n  if (\n    !lwaResponse ||\n    !lwaResponse.access_token ||\n    !lwaResponse.expires_in ||\n    lwaResponse.expires_in < 0\n  ) {\n    console.log(\n      \"Encountered an error on login: \" +\n      util.inspect(lwaResponse, { showHidden: true, depth: null })\n    );\n    return false;\n  }\n  return true;\n}\n","import React from \"react\";\nimport { Redirect } from \"react-router-dom\";\n\n/*\n  Component to redirect to home page. This component is currently rendered \n  for paths that are not registered URIs. \n*/\nexport default class DefaultRedirect extends React.Component {\n  render() {\n    return <Redirect to=\"/\" />;\n  }\n}\n","import React from \"react\";\nimport \"./LoginFailedScreen.css\";\n\nexport default function LoginFailedScreen() {\n  return (\n    <div id=\"loginfailed-screen\">\n      <h1> Login Failed </h1>\n      <h1> This is just a placeholder. We might want to redirect the user to the login page or at least have a link here to let the user try again or go home. </h1>\n    </div>\n  );\n}\n","import React from \"react\";\nimport { Route, Switch } from \"react-router-dom\";\nimport LoginHandler from \"LoginHandler/LoginHandler\";\nimport DefaultRedirect from \"DefaultRedirect/DefaultRedirect\";\nimport LoginFailedScreen from \"../LoginFailedScreen/LoginFailedScreen\";\n\nexport default function Routes(props) {\n  return (\n    <Switch>\n      <Route\n        exact\n        path={[\"/authresponse\"]}\n        render={routeProps => <LoginHandler {...routeProps} {...props} />}\n      />\n      <Route\n        exact\n        path={[\"/access_denied\"]}\n        render={routeProps => <LoginFailedScreen {...routeProps} />}\n      />\n      {/* TODO: Redirect to NotFound Page for other paths rather than redirecting\n         to home. https://github.com/s-maheshbabu/silent-alexa/issues/55 */}\n      <Route\n        exact\n        path=\"/:foo+\"\n        render={routeProps => <DefaultRedirect {...routeProps} />}\n      />\n    </Switch>\n  );\n}\n","import React, { Component } from \"react\";\nimport \"./App.css\";\n\nimport Header from \"Header/Header\";\nimport Body from \"Body/Body\";\nimport Footer from \"Footer/Footer\";\nimport Routes from \"Routes/Routes\";\n\nclass App extends Component {\n  render() {\n    return (\n      <div id=\"page\">\n        <Routes />\n        <Header />\n        <Body />\n        <Footer />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import React from \"react\";\nimport IllegalArgumentError from \"errors/IllegalArgumentError\";\nimport Cookies from \"js-cookie\";\nimport util from \"util\";\n\nexport const AuthContext = React.createContext();\n\nexport const AMAZON_LOGIN_COOKIE = \"amazon_Login_accessToken\";\n\n// TODO This class is using the presence of AMAZON_LOGIN_COOKIE to mean that the user\n// is authenticated. The assumption is that Cookies.get won't return expired cookies. \n// Is it true? If not, we should check for expiration of cookies.\nexport default ({ children }) => {\n\n  const defaultContext = {\n    setLWAResponse: lwaResponse => {\n      _persist(lwaResponse);\n    },\n    isAuthenticated: () => Cookies.get(AMAZON_LOGIN_COOKIE) !== undefined,\n    getAccessToken: () => {\n      return Cookies.get(AMAZON_LOGIN_COOKIE);\n    },\n    clear: () => {\n      Cookies.remove(AMAZON_LOGIN_COOKIE);\n    }\n  };\n  return (\n    <AuthContext.Provider value={defaultContext}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\nconst _persist = lwaResponse => {\n  const numberOfSecondsInADay = 86400;\n\n  if (lwaResponse && lwaResponse.access_token && lwaResponse.expires_in) {\n    Cookies.set(AMAZON_LOGIN_COOKIE, lwaResponse.access_token, {\n      expires: lwaResponse.expires_in / numberOfSecondsInADay, // TODO Why are cookies expiring in an hour?\n      secure: false // TODO: Change localhost to also use https and then change this to true.\n    });\n  } else {\n    const serializedLWAResponse = util.inspect(lwaResponse, {\n      showHidden: true,\n      depth: null\n    });\n    throw new IllegalArgumentError(\n      `LoginWithAmazon Authorization response is undefined or \n        doesnt have access_token/expires_in.\n        lwaResponse: ${serializedLWAResponse}`\n    );\n  }\n};\n","// In production, we register a service worker to serve assets from local cache.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the \"N+1\" visit to a page, since previously\n// cached resources are updated in the background.\n\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\n// This link also includes instructions on opting out of this behavior.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport default function register() {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebookincubator/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Lets check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://goo.gl/SC7cgQ'\n          );\n        });\n      } else {\n        // Is not local host. Just register service worker\n        registerValidSW(swUrl);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the old content will have been purged and\n              // the fresh content will have been added to the cache.\n              // It's the perfect time to display a \"New content is\n              // available; please refresh.\" message in your web app.\n              console.log('New content is available; please refresh.');\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type').indexOf('javascript') === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"index.css\";\nimport App from \"App/App\";\nimport AuthContext from \"auth/AuthContextProvider\";\nimport { BrowserRouter as Router } from \"react-router-dom\";\nimport registerServiceWorker from \"registerServiceWorker\";\nimport { CookiesProvider } from 'react-cookie';\n\nReactDOM.render(\n  <Router>\n    <CookiesProvider>\n      <AuthContext>\n        <App />\n      </AuthContext>\n    </CookiesProvider>\n  </Router>,\n  document.getElementById(\"root\")\n);\nregisterServiceWorker();\n","const paths = Object.freeze({\n  EVENTS: \"/v20160207/events\",\n  DIRECTIVES: \"/v20160207/directives\"\n});\n\nconst urls = Object.freeze({\n  NA: \"https://avs-alexa-na.amazon.com\",\n  EU: \"https://avs-alexa-eu.amazon.com\",\n  FE: \"https://avs-alexa-fe.amazon.com\"\n});\n\nmodule.exports = {\n  urls: urls,\n  paths: paths\n};\n"],"sourceRoot":""}